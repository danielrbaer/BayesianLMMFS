solve_Sigma<-solve(Sigma)
if(mcmc %% mcmc_div == 0){
cat(mcmc)
cat("..")
}
for(k in 1:K){
#Relevant indices for p_k:
k_select<-X_dim_df[k,]
p_select<-k_select$lag_cum_p_k:k_select$cum_p_k
#----------------------------------------------------------------------------------#
#Update V_k (p_k x p_k) via tau_l2:####
diag_V_k<-tau_l2[p_select]
if(p_k[k]>1){
V_k[[k]]<-diag(c(diag_V_k))
}else{
V_k[[k]]<-diag_V_k
}
#----------------------------------------------------------------------------------#
#Define I_J kron V_k:
V_k_star<-
(I_J%x%V_k[[k]])
#-------------------------------#
#Define I_pk:
I_pk<-diag(p_k[k])
#-------------------------------#
#Calculate Omega_k (Cp_k x Cp_k):
Omega_k<-
(
V_k_star%*%
t(X_STAR_k[[k]])%*%
X_STAR_k[[k]]%*%
V_k_star
)+
(
sigma2*
(solve_Sigma%x%I_pk)
)
#Calculate inverse once to save comp time:
inv_Omega_k<-solve(Omega_k)
#-------------------------------#
#Calculate z_k (Jn x 1):
z_k<-
vec_Y_transpose-
(
X_STAR_NOT_k[[k]]%*%beta_NOT_k[[k]]+
Z_mat%*%b
)
#-------------------------------#
#Calculate f_k (1 x 1):
f_k<-
t(z_k)%*%
X_STAR_k[[k]]%*%
V_k_star%*%
inv_Omega_k%*%
V_k_star%*%
t(X_STAR_k[[k]])%*%
z_k
#----------------------------------------------------------------------------------#
#Update pi_0k (K x 1):####
#Calculate numerator of pi_0k posterior prob. parameter:
pi_0k_prob_num<-
theta_beta_tilde*
(sigma2)^(0.5*J*p_k[k])*
(
det(Sigma)
)^(-p_k[k]/2)*
exp(
(1/(2*sigma2))*f_k
)*
(
det(
inv_Omega_k
)
)^(1/2)
#Convert to numeric value from dense matrix:
pi_0k_prob_num<-as.numeric(pi_0k_prob_num)
if(pi_0k_prob_num==Inf){
pi_0k_prob_num<-
10^20
}
pi_0k[k]<-
rbinom(
n=1,
size=1,
prob=pi_0k_prob_num/((1-theta_beta_tilde)+pi_0k_prob_num)
)
#----------------------------------------------------------------------------------#
#Update beta_tilde_k (p_k*J x 1):####
#N.b. rcpp code does not like sparse matrices, so
#transform posterior mean and vcv matrix back
#to dense matrices here:
post_mean_beta_tilde_k<-
(inv_Omega_k%*%
V_k_star%*%
t(X_STAR_k[[k]])%*%
z_k
)%>%
as.matrix()
post_cov_beta_tilde_k<-
(sigma2*
inv_Omega_k)%>%
as.matrix()
#-------------------------------#
beta_tilde_k[[k]]<-
(
(pi_0k[k])*
MASS::mvrnorm(
n=1,
mu=post_mean_beta_tilde_k,
Sigma=post_cov_beta_tilde_k
)%>%
matrix(.,
nrow=p_k[k]*J,
ncol=1)
+
(1-pi_0k[k])*
matrix(0,
nrow=(p_k[k]*J),
ncol=1)
)
#-------------------------------#
#Calculate Beta_tilde_k (p_k x J) via updated beta_tilde_k (p_k*J x 1):
Beta_tilde_k[[k]]<-
beta_tilde_k[[k]]%>%
matrix(.,
nrow=p_k[k],
ncol=J)
#-------------------------------#
#Then, calculate Beta_k (p_k x J) via V_k (p_k x p_k) :
Beta_k[[k]]<-
V_k[[k]]%*%
Beta_tilde_k[[k]]
#Calculate beta_k (p_kC x 1)
beta_k[[k]]<-matrix(Beta_k[[k]],
nrow=p_k[k]*J,
ncol=1)
#----------------------------------------------------------------------------------#
}#end of k loop for Gibbs sampler
beta_k
for(l in 1:p){
#Calculate z_l (Jn x 1):
z_l<-
vec_Y_transpose-
(X_STAR_NOT_l[[l]]%*%
beta_NOT_l[[l]]+
Z_mat%*%b)
#-------------------------#
#Calculate m_l (nJ x1):
m_l<-
X_STAR_l[[l]]%*%
beta_tilde_l[[l]]
#Define m_l^T once here to improve comp time:
m_lT<-t(m_l)
#-------------------------#
#Calculate sigma_l_inverse (1x1)
sigma_l_inverse<-
s2/
(
sigma2+
(s2*m_lT%*%m_l)
)
#-------------------------#
#Calculate f_l (1 x 1):
f_l<-
t(z_l)%*%
m_l%*%
sigma_l_inverse%*%
m_lT%*%
z_l
#Turn into a numeric var. from a dense matrix:
f_l<-as.numeric(f_l)
#----------------------------------------------------------------------------------#
#Update tau_l2:####
tau_l2[l]<-
(
(pi_0l[l])*
truncnorm::rtruncnorm(n=1,
a=0,
b=Inf,
mean=
sigma_l_inverse*
m_lT%*%
z_l,
sd=
sqrt(
sigma2*
sigma_l_inverse
)
)+
(1-pi_0l[l])*
matrix(0,
nrow=1,
ncol=1)
)
#----------------------------------------------------------------------------------#
#Update pi_0l:####
#Calculate numerator of pi_0l posterior prob. parameter:
pi_0l_prob_num<-
theta_tau2*
2*
sqrt(sigma2/s2)*
exp(
f_l/(2*sigma2)
)*
sqrt(
sigma_l_inverse
)*
pnorm(
q=sqrt(f_l/sigma2),
mean=0,
sd=1
)
#Turn into a numeric var. from a dense matrix:
pi_0l_prob_num<-as.numeric(pi_0l_prob_num)
if(pi_0l_prob_num==Inf){
pi_0l_prob_num<-
10^20
}
pi_0l[l]<-
rbinom(
n=1,
size=1,
prob=
pi_0l_prob_num/
((1-theta_tau2)+pi_0l_prob_num)
)
#----------------------------------------------------------------------------------#
}#end of l loop for Gibbs sampler
Beta<-lapply(Beta_k,as.data.frame)%>%
dplyr::bind_rows()%>%
as.matrix()
beta<-
matrix(Beta,
nrow=p*J,
ncol=1)
Beta_tilde<-lapply(Beta_tilde_k,as.data.frame)%>%
dplyr::bind_rows()%>%
as.matrix()
for(k in 1:K){
k_select<-X_dim_df[k,]
p_select<-k_select$lag_cum_p_k:k_select$cum_p_k
p_NOT_select<-which(((1:p)%in%p_select)==F)
Beta_NOT_k<-Beta[p_NOT_select,]%>%
matrix(.,
nrow=length(p_NOT_select),
ncol=J)
beta_NOT_k[[k]]<-matrix(Beta_NOT_k,
nrow=length(p_NOT_select)*J,
ncol=1)
}
for(l in 1:p){
p_select<-l
p_NOT_select<-which(((1:p)%in%p_select)==F)
Beta_NOT_l<-Beta[p_NOT_select,]%>%
matrix(.,
nrow=length(p_NOT_select),
ncol=J)
beta_NOT_l[[l]]<-matrix(Beta_NOT_l,
nrow=length(p_NOT_select)*J,
ncol=1)
}
for(l in 1:p){
p_select<-l
beta_tilde_l[[l]]<-
Beta_tilde[p_select,]%>%
matrix(.,
nrow=J,
ncol=1)
}
Sigma_b<-
t(Z_mat)%*%Z_mat+
(sigma2*
(diag(n)%x%solve(G)))
inv_Sigma_b<-solve(Sigma_b)
r_b<-
vec_Y_transpose-
X_kron_mat%*%beta
post_mean_b<-
(inv_Sigma_b%*%
t(Z_mat)%*%
r_b
)%>%
as.matrix()
post_cov_b<-
(
sigma2*
inv_Sigma_b
)%>%
as.matrix()
b<-
MASS::mvrnorm(
n=1,
mu=post_mean_b,
Sigma=post_cov_b
)%>%
matrix(.,
nrow=n*q,
ncol=1)
b
b_mat<-matrix(b,
nrow=q,
ncol=n,
byrow=F)
post_scale_G<-
C_0+
b_mat%*%t(b_mat)
G<-
MCMCpack::riwish(v=
nu_0+n,
S=post_scale_G
)
d=nrow(Y_transpose)
nu_0=ncol(Z[[1]])
alpha=10^-3
gamma=10^-3
o=10^-3
u=10^-3
a=1
b=1
g=1
h=1
just_Beta_raw_MCMC_output=T
raw_MCMC_output=F
post_scale_G<-
C_0+
b_mat%*%t(b_mat)
G<-
MCMCpack::riwish(v=
nu_0+n,
S=post_scale_G
)
theta_beta_tilde<-rbeta(n=1,
shape1=
a+sum(pi_0k),
shape2=
b+K-sum(pi_0k)
)
theta_tau2<-rbeta(n=1,
shape1=
g+
(pi_0l%>%sum),
shape2=
h+p-
(pi_0l%>%sum))
r<-
vec_Y_transpose-
(X_kron_mat%*%beta+Z_mat%*%b)
Z_mat<-
Z_data_matrix_fn(data_list=Z,
J=J,
q=q)
Z_mat
z_k<-
vec_Y_transpose-
(
X_STAR_NOT_k[[k]]%*%beta_NOT_k[[k]]+
Z_mat%*%b
)
b
uninstall('BayesianLMMFS')
#Packages:
library("devtools")
library('roxygen2')
library("mathjaxr")
library('dplyr')
library('ggplot2')
library("knitr")
library('Rdpack')
setwd('C:/Users/baerd/Desktop/BayesianLMMFS')
setwd("..")
install("BayesianLMMFS")
library('BayesianLMMFS')
?BayesianLMMFS()
BayesianLMMFS()
set.seed(123)
n<-100
p<-16
K<-4
J<-3
p_k<-rep(p/K,K)
q<-2
X<-matrix(rnorm(n*p),nrow=n,ncol=p)
Beta_k<-list()
for(k in 1:K){
Beta_k[[k]]<-matrix(rnorm(J*p_k[k]),nrow=p_k[k],ncol=J)
}
Beta_k[[1]]<-0*Beta_k[[1]]
Beta_k[[2]][1,]<-0*Beta_k[[2]][1,]
Beta<-dplyr::bind_rows(lapply(Beta_k,as.data.frame))%>%as.matrix
beta<-matrix(Beta,nrow=J*p,ncol=1)
Z<-list()
for(i in 1:n){
Z[[i]]<-matrix(0,nrow=J,ncol=q)
#For random intercept:
Z[[i]][,1]<-1
#For random slope:
Z[[i]][,2]<-sort(rexp(n=J,rate=1/20))
#Make first occasion 0:
Z[[i]][,2][1]<-0
}
sigma2<-1/20
sigma2_I_J<-sigma2*diag(J)
G<-matrix(c(1/2,-10^-3,
-10^-3,10^-4),
q,q,byrow = T)
Y_transpose<-matrix(0,nrow=J,ncol=n)
for (i in 1:n){
#This is X_i (J x Jp):
X_kron_i<-diag(J)%x%t(X[i,])
#Mean structure:
SS_MS_i<-X_kron_i%*%beta
#Covariance structure:
cov_y_i<-Z[[i]]%*%G%*%t(Z[[i]])+sigma2_I_J
#Outcome data:
Y_transpose[,i]<-MASS::mvrnorm(n=1,
mu=SS_MS_i,
Sigma=cov_y_i)
}
I_J<-diag(J)
I_q<-diag(q)
BayesianLMMFS::BayesianLMMFS
I_J<-diag(J)
I_q<-diag(q)
model_results<-
BayesianLMMFS::BayesianLMMFS(
Y_transpose,
X,
Z,
p_k,
nsim=2000,
burn=1000,
thin=1,
Q=10^-3*I_J,
C_0=10^-3*I_q
)
uninstall('BayesianLMMFS')
#Packages:
library("devtools")
library('roxygen2')
library("mathjaxr")
library('dplyr')
library('ggplot2')
library("knitr")
library('Rdpack')
setwd('C:/Users/baerd/Desktop/BayesianLMMFS')
devtools::document()
setwd("..")
install("BayesianLMMFS")
?BayesianLMMFS()
set.seed(123)
n<-100
p<-16
K<-4
J<-3
p_k<-rep(p/K,K)
q<-2
X<-matrix(rnorm(n*p),nrow=n,ncol=p)
Beta_k<-list()
for(k in 1:K){
Beta_k[[k]]<-matrix(rnorm(J*p_k[k]),nrow=p_k[k],ncol=J)
}
Beta_k[[1]]<-0*Beta_k[[1]]
Beta_k[[2]][1,]<-0*Beta_k[[2]][1,]
Beta<-dplyr::bind_rows(lapply(Beta_k,as.data.frame))%>%as.matrix
beta<-matrix(Beta,nrow=J*p,ncol=1)
Z<-list()
for(i in 1:n){
Z[[i]]<-matrix(0,nrow=J,ncol=q)
#For random intercept:
Z[[i]][,1]<-1
#For random slope:
Z[[i]][,2]<-sort(rexp(n=J,rate=1/20))
#Make first occasion 0:
Z[[i]][,2][1]<-0
}
sigma2<-1/20
sigma2_I_J<-sigma2*diag(J)
G<-matrix(c(1/2,-10^-3,
-10^-3,10^-4),
q,q,byrow = T)
Y_transpose<-matrix(0,nrow=J,ncol=n)
for (i in 1:n){
#This is X_i (J x Jp):
X_kron_i<-diag(J)%x%t(X[i,])
#Mean structure:
SS_MS_i<-X_kron_i%*%beta
#Covariance structure:
cov_y_i<-Z[[i]]%*%G%*%t(Z[[i]])+sigma2_I_J
#Outcome data:
Y_transpose[,i]<-MASS::mvrnorm(n=1,
mu=SS_MS_i,
Sigma=cov_y_i)
}
I_J<-diag(J)
I_q<-diag(q)
model_results<-
BayesianLMMFS::BayesianLMMFS(
Y_transpose,
X,
Z,
p_k,
nsim=2000,
burn=1000,
thin=1,
Q=10^-3*I_J,
C_0=10^-3*I_q
)
model_results$MCMC_summary%>%dplyr::filter(parameter=='beta')
model_results$MCMC_summary%>%dplyr::filter(parameter=='beta')%>%head
Beta
model_results$MCMC_summary%>%dplyr::filter(parameter=='beta')
uninstall('BayesianLMMFS')
